# 作用域提升考题

## 请说出下面三段代码的执行结果（输出情况）

```js
function foo(){
	console.log(n)
    var n = 200
    console.log(n)
}
var n = 100
foo()
```

```js
function foo(){
    var a = b = 1
}

foo()
console.log(b)
console.log(a)
```

```js
function foo(){
    function bar(a){
        i = 3
        console.log(a + i)
    }
    for ( var i = 0 ; i < 10 ; i++){
        bar ( i * 2 )
    }
}
foo()
```



# 闭包考题

## 1、请简述闭包、闭包可能带来的问题，以及应该如何解决

## 2、实现一下函数柯里化

```js
//提示1：函数foo需要的参数个数可以通过foo.length获取





```

# this考题

## 请说出下面三段代码的执行结果（输出情况）

```js
const foo = function(fn){
  fn()
}
new foo(()=>{
  console.log(this)   
})
```

```js
var name = "222";
var a = {
	name: "111",
	say: function () {
		console.log(this.name);
	}
}
var fun = a.say;
fun();		
a.say();	
 
var b = {
	name : "333",
	say: function (func){
		func();
	}
}

 
b.say(a.say);	
b.say = a.say;	
b.say();		
```

## 实现一下call方法

```js
//实现函数体，要求大体达到原生call函数的效果
//提示1：第一个参数是要绑定的对象，如果传入普通数据类型需要变成对象，如果是空对象则指向window
//提示2：foo.call(),如何在call的函数体中获取要绑定this的函数foo
//提示3：如何在函数体内部给foo绑定this

Function.prototype.wjjCall = function(thisArg,...args){

}

function foo(arr){
    console.log("foo函数被执行",this,arr)
}

foo.wjjCall({},123)
```

# 原型链考题

## 1、请说出下面代码段的输出结果

```js
console.log(Function.prototype === new Function().__proto__)
console.log(Function.prototype === new Function().__proto__)
```

## 2、实现es5的继承

```js
//实现student继承person
//提示1：借用构造方法
//提示2：修改原型prototype
function Person(name,friends){
	this.name = name
	this.friends = friends
}
Person.prototype.eating = function(){
	console.log(this.name + " is eating")
}

function Student(sno,name,friends){
	
}
```

## 3、用es6实现上面的继承

```js
class Person{
    constructor(name,friends){
        this.name = name
        this.friends = friends
    }
}
//请写出class Student继承Person的代码
```

