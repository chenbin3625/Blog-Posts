# node.js学习笔记

# 搭建自己的脚手架

> 使用封装的思想

  win/Mac 平台终端命令差异

需要判断终端 windows需要在命令后加.cmd



## buffer和浏览器的时间循环

### buffer：

![image-20220430114525450](https://ypyun-cdn.u1n1.com/img/picgo/2022/04/30/20220430114525.png)

![image-20220430114630385](https://ypyun-cdn.u1n1.com/img/picgo/2022/04/30/20220430114630.png)

### 事件循环

与js高级重复 跳过不再赘述

# 事件循环：微任务和宏任务

浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 **事件循环** 的。

理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。

在本章中，我们首先介绍事件循环工作方式的理论细节，然后介绍该知识的实际应用。

## 

**事件循环** 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。

引擎的一般算法：

1. 当有任务时：
   - 从最先进入的任务开始执行。
2. 休眠直到出现任务，然后转到第 1 步。

当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。

任务示例：

- 当外部脚本 `<script src="...">` 加载完成时，任务就是执行它。
- 当用户移动鼠标时，任务就是派生出 `mousemove` 事件和执行处理程序。
- 当安排的（scheduled）`setTimeout` 时间到达时，任务就是执行其回调。
- ……诸如此类。

设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。

一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。

多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：

例如，当引擎正在忙于执行一段 `script` 时，用户可能会移动鼠标而产生 `mousemove` 事件，`setTimeout` 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。

队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 `script` 后，它会处理 `mousemove` 事件，然后处理 `setTimeout` 处理程序，依此类推。

到目前为止，很简单，对吧？

两个细节：

1. 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。
2. 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。

## 总结

更详细的事件循环算法（尽管与 [规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) 相比仍然是简化过的）：

1. 从 **宏任务** 队列（例如 “script”）中出队（dequeue）并执行最早的任务。

2. 执行所有

   微任务

   ：

   - 当微任务队列非空时：
     - 出队（dequeue）并执行最早的微任务。

3. 如果有变更，则将变更渲染出来。

4. 如果宏任务队列为空，则休眠直到出现宏任务。

5. 转到步骤 1。

安排（schedule）一个新的 **宏任务**：

- 使用零延迟的 `setTimeout(f)`。

它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。

此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。

安排一个新的 **微任务**：

- 使用 `queueMicrotask(f)`。
- promise 处理程序也会通过微任务队列。

在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。

所以，我们可以使用 `queueMicrotask` 来在保持环境状态一致的情况下，异步地执行一个函数。

> **Web Workers**
>
> 对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 [Web Workers](https://html.spec.whatwg.org/multipage/workers.html)。
>
> 这是在另一个并行线程中运行代码的方式。
>
> Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。
>
> Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。

## Stream

![image-20220501114907341](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/0120220501114907.png)



## http模块

#### web服务器

![image-20220501130133648](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501130133.png)

初体验

![image-20220501134726337](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501134726.png)



### 创建服务器的方式

![image-20220501132849315](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501132849.png)

![image-20220501132932711](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501132932.png)

![image-20220501135150169](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501135150.png)

![image-20220501135431602](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501135431.png)

![image-20220501135659023](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501135659.png)



## 认识web框架

## express

 ![image-20220501151527791](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501151528.png)

![image-20220501151909052](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501151909.png)

![image-20220501193403119](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501193403.png)

![image-20220501201830703](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/01/20220501201830.png)

![image-20220502123516339](https://ypyun-cdn.u1n1.com/img/picgo/2022/05/02/20220502123516.png)
