title: 红红的面经
author: chenbin
tags:
  - java
categories:
  - 红红
date: 2022-04-10 21:10:00
---
# java基础

## JDK

JDK全称Java SE Development kit，即java标准版开发包，是Oracle提供的一套用于开发java应用程序的开发包，它提供编译，运行java程序所需要的各种工具和资源，包括java编译器，java运行时环境，以及常用的java类库等。

## JRE

JRE为Java Runtime Environment的简称，Java Runtime Environment包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具--编译器、调试器和其他工具。

## OOP（面向对象编程）的特性

1. 封装 

   隐藏类的内部实现机制，只暴露一些访问方法来访问数据，提高代码复用性和安全性。

2. 继承

   能够使用现有类的所有功能，并能对这些功能进行扩展，提高代码复用性

3. 多态

   父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高程序的拓展性

## OOP6大设计原则

1. OCP原则(开闭原则):

   一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

2. SRP原则(职责单一原则)： 

   应该有且只有一个原因引起类的变更。

3. LSP原则(里氏替换原则):

   所有引用基类的地方必须能透明地使用其子类的对象

4. DIP原则（依赖倒置原则)∶

   高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节而，具体细节应该依赖于抽象

5. ISP原则(接口隔离原则):

   客户端不应该依赖它不需要的接口;类间的依赖应该建立在最小的接口上

6. LoD法则(迪米特法则):

   又称最少知识原则(Least Knowledge Principle,LKP) ,一个对象应该尽可能少得去了解其他对象。



## 集合体系

- List、Set、Map是集合体系的三个接口。
- 其中List和Set继承了Collection接口。
- List有序且元素可以重复，默认大小为10；ArrayList、LinkedList和Vector是三个主要的实现类。
- Set元素不可以重复，HashSet和TreeSet是两个主要的实现类。
- Map也属于集合系统，但和Collection接口不同。Map是key-value键值对形式的集合，key值不能重复，value可以重复；HashMap、TreeMap和Hashtable是三个主要的实现类。
- 不同于HashMap的哈希映射，TreeMap实现了红黑树的结构，形成了一颗二叉树。

### ArrayList 

- 优点：

  1、因为其底层是数组，所以修改和查询效率高。

  2、自动扩容（1.5倍）。

- 缺点：

  1、插入和删除效率不高。

  2、线程不安全。

### LinkList

- LinkList以双向链表实现，链表无容量限制，但双向链表本身使用了更多空间，每插入一个元素都要构造一个额外的Node对象，也需要额外的链表指针操作。允许元素为null，线程不安全。



### Java集合的快速失败机制 “fail-fast”？

是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。

例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。

原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

解决办法：

- 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。
- 使用CopyOnWriteArrayList来替换ArrayList



## 泛型

java泛型就是将类型参数化，在使用/调用时传入具体的类型，如List<String>a1=new ArrayList<>();

## 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢?它内部原理是什么呢?

先看这段代码:
```
public class Outer {

​	void outMethod(){

​		final int a =10;

​		class Inner {
​				void innerMethod(){
​						system.out.println(a);
​				}
​		}
​	}
}
```
以上例子，为什么要加fina呢?是因为生命周期不一致，局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。

## String

- 直接使用双引号声明出来的 String 对象会直接存储在常量池中。
- 如果不是用双引号声明的String 对象，可以使用String 提供的 intern方法。String.intern()是一个Native方法，它的作用(在JDK1.6和1.7操作不同)是:如果运行时常量池中已经包含一个等于此String 对象内容的字符串，则返回常量池中该字符串的引用;如果没有，在jdk1.6中，将此String对象添加到常量池中，然后返回这个String对象的引用(此时引用的串在常量池。在jdk1.7中，放入一个引用，指向堆中的String对象的地址，返回这个引用地址（此时引用的串在堆)。
- String StringBuffer StringBuilder
  - 运行速度快慢为：StringBuilder > StringBuffer > String
  - String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。
  - 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的

## 接口和抽象类

- 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

### **相同点**

- 接口和抽象类都不能实例化
- 都位于继承的顶端，用于被其他实现或继承
- 都包含抽象方法，其子类都必须覆写这些抽象方法

### 不同点

|    参数    | 抽象类                                                       | 接口                                                         |
| :--------: | :----------------------------------------------------------- | :----------------------------------------------------------- |
|    声明    | 使用abstract关键字声明                                       | 使用interface关键字声明                                      |
|    实现    | 子类使用extends关键字继承抽象类，如果子类不是抽象类，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口，它需要提供接口中所有声明的方法的实现 |
|   构造器   | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符                           | 接口方法默认修饰符是public，并且不允许定义为private或者protected |
|   多继承   | 一个类最多只能继承一个抽象类                                 | 一个类可以实现多个接口                                       |
|  字段声明  | 抽象类的字段声明可以是任意的                                 | 接口的字段默认都是static和final的                            |



## Hash扩容

- 默认容量是16，指定的容量如果不是2的幂次，会被HashMap修改为2的幂次。默认加载因子是0.75，超过容量*加载因子就会发生扩容。
- 扩容时会扩容到当前的两倍，因为初始容量永远是2的幂次，所以扩容后的容量也永远是2的幂次。
- 保持2的n次幂可以充分散列，减少哈希碰撞，并且由于二进制的运算速度远高于取模的速度，将计算数据下标的方式从取模变为二进制计算，提高处理效率。
- 新旧两次下标的计算：扩容时，新的参与运算结果的位如果是0则下标不动，如果是1则下标位置加扩容前的数组长度。



## hash冲突处理方式

1. 再哈希法（将计算出来的hash值进行hash值计算，直到没有冲突）
2. 线性探测法（寻找下一个哈希地址，直到没有冲突）
3. 拉链法（建立链表，存储在链表中，hashmap处理冲突的方式）



## 访问修饰符

|  修饰符   | 当前类 | 同包 | 子类 | 其他包 |
| :-------: | :----: | :--: | :--: | :----: |
|  private  |   √    |  ×   |  ×   |   ×    |
|  default  |   √    |  √   |  ×   |   ×    |
| protected |   √    |  √   |  √   |   ×    |
|  public   |   √    |  √   |  √   |   √    |



## NoClassDefFoundError 和 ClassNotFoundException 区别

NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。

引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致；

ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，**通过传入的类路径参数没有找到该类**，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，**另一个加载器又尝试去加载它**。



## 运行时异常和一般异常(受检异常)区别是什么

- 运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。
- 受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 **Java 编译器会检查受检异常**。

RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。



## 反射的概念

​        JAVA反射机制是在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。



### 获取Class对象的三种方式

- ### 全类名:包名+类名

  ### Class userClass = Class.forName( "com.xxl.model.User");

- ### 2类名.class

  ### Class userClass = User.class;

- ### 3.对象.getClass()

  ### User user = new User();
Class userClass = user.getClass( );

尽管有三种方式获取Class对象，但是我们一般采用上述第一种方式。
拿到Class对象之后，我们就可以操作与它相关的方法了。



# 设计模式

## 简单工厂模式

- 简单工厂模式又叫静态工厂方法，其实质是由一个工厂类根据传入的参数，动态决定应该创建哪
  一个产品类。

## 工厂模式



## 单例模式

- 懒汉式
- 饿汉式
- 双重校验锁

  - volatile关键字的作用是防止指令重排序，分配内存、初始化、指向内存空间三个步骤没有原子性，如果不加会导致多线程中返回未完全初始化的实例,加了之后可以起到内存屏障的作用，即在三个步骤执行完毕之前不能被读取。

- 静态内部类

## 原型模式

clone 直接复制已有对象，新建初始对象比较消耗资源时用clone可以提高效率

## 适配器模式





# JVM



## 内存结构



<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220210213220064.png" alt="image-20220210213220064" style="zoom: 67%;" />

- 程序计数器：保存所属线程当前的执行位置。（唯一没有规定OutOfMemoryError情况的区域）
- Java内存区域大致可以分为堆内存和栈内存
  - 栈内存分java虚拟机栈，本地方法栈。
  - java虚拟机栈为执行java方法服务，本地方法栈为执行本地方法服务。
  - java虚拟机栈中有局部变量表，局部变量表中存放基本数据类型(boolean,byte,char,short,int,float,long,double)、对象引用类型、returnAddress类型(指向一条字节码指令的地址)
- 运行时常量池在方法区中，方法区即永久代（jdk1.8之后被元空间替代，元空间由本地内存存储，静态变量和字符串常量池转移到了堆中，剩余的保留在元空间）
- 堆内存负责存放对象实例，对象实例在这里分配内存，如果对象实例无法在堆内存中获取到足够的内存，jvm会抛出oom异常。



## **类加载器** 

就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

### 双亲委派模型（类加载时会先请求父类加载，父类不能完成的才会在子类中加载）

- 避免了类的重复加载
- 避免核心类被篡改

### 打破方式：

1. 继承ClassLoader类，重写loadClass()和findClass()
2. 使用线程上下文类加载器
3. 热部署中由于需要使用自定义的类加载器，在搜索类加载器时不再遵循双亲委派模型



## 垃圾收集器

### CMS

目标:获取最短垃圾回收停顿时间，使用多线程的标记-清除算法
一种以获取最短回收停顿时间为目标的收集器。适合需要与用户交互的程序，良好的响应速度能提升用户体验

过程:

- 初始标记:只是标记一下GC Roots能直接关联到的对象，速度很快。会暂停所有的工作线程。
- 并发标记:进行GC Roots Tracing (可达性分析)的过程
- 重写标记:会Stop The -Worid。为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记阶段稍长些，但远比并发标记的时间短。
- 并发清除:回收内存

耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以是并发执行的



缺点:

- 并发阶段，虽然不会导致用户线程暂停，但是会占用一部分资源(CPU线程)，导致应用变慢，吞吐量降低。默认启动收集线程数是(CPU数量+3)/4。即当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大。
- 无法清除浮动垃圾。并发清除阶段，用户线程还在运行，还会产生新垃圾。这些垃圾不会在此次GC中被标记，只能等到下次GC被回收
- 标记-清除算法会产生大量不连续内存，导致分配大内存时内存不够，提前触发Full GC



### G1

- 既适用于新生代，也适用于老年代
- 空间整合:使用标记-整理算法，不产生碎片空间
- 可以非常精准的控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。



G1收集器避免全区域垃圾收集，把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所运行的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。



- young GC:新生代eden区没有足够可用空间时触发。存活对象移到survivor区，或晋升old区
- mixed GC: 当old区对象很多时，老年代对象空间占堆总空间的比值达到阈值会触发，它除了回收年轻代，也回收部分老年代



回收步骤

- 初始标记:只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，在筛选回收时能在空的region区复制存活的对象。这阶段需要停顿线程(STW)，但耗时很短，共用YGC的停顿，所以一般伴随着YGC发生。
- 并发标记:进行可达性分析，找出存活对象，耗时长，但可与用户线程并发执行。
- 最终标记:修正并发标记阶段用户线程运行导致的变动记录。会STW，但可以并行执行，时间不会很长。
- 筛选回收:根据每个region的回收价值和回收成本排序，根据用户配置的GC停顿时间开始回收。



- 当对象分配过快，mixed GC来不及回收，G1会退化，触发Ful GC，它使用单线程的Serial收集器来回收，整个过程STW，要尽量避免这种情况。
- 当内存很少的时候（存活对象占用大量空间)，没有足够空间来复制对象，会导致回收失败。这时会保留被移动过的对象和没移动的对象，只调整引用。失败发生后，收集器认为存活对象被移动了，有足够空间让应用程序使用，于是用户线程继续工作，等待下一次触发GC。如果内存不够，就会触发Full GC。

### GC ROOTS

- jvm的GC ROOTS有哪几个地方呢?
  1、虚拟机栈（局部变量表中引用的对象)
  2、本地方法栈（本地方法引用的对象)
  3、方法区中静态属性引用的对象
  4、方法区中静态常量池中引用的对象
  以上几个地方是垃圾回收开始扫描对象引用链的GC ROOTS。



# MySql

## 三范式

- ### 第一范式

  每一列都是不可分割的原子数据项

  如某一列为（系名/系主任），应当分为系名、系主任两列。

- ### 第二范式

  满足第一范式并达到：非属性码的属性必须完全函数依赖于主码

  如某表为学号、姓名、课程、分数。姓名完全函数依赖于学号，分数完全函数依赖于（学号，课程），因学号被选为主码，所以分数不完全函数依赖于学号，表应该拆分为（学号，姓名）、（学号，课程，分数）两表。

- ### 第三范式

  满足第二范式并达到：消除传递函数依赖。

  如某表为学号、姓名、系名、系主任。姓名->系名->系主任，所以应当将表拆分为（学号，姓名，系名）、（系名，系主任）。

## 事务隔离级别

|         事务隔离级别         | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
|    串行化（serializable）    |  否  |     否     |  否  |



## 存储引擎

| 功能         | InnoDB       | MyISAM     | Memory     |
| ------------ | ------------ | ---------- | ---------- |
| 存储限制     | 64TB         | 256TB      | RAM        |
| 支持事务     | Yes          | No         | No         |
| 支持全文索引 | No           | Yes        | No         |
| 支持树索引   | Yes          | Yes        | Yes        |
| 支持哈希索引 | No           | No         | No         |
| 支持数据缓存 | Yes          | No         | N/A        |
| 支持外键     | Yes          | No         | No         |
| 锁范围       | 可使用行级锁 | 使用表级锁 | 使用表级锁 |

1. 如果要提供提交、回滚和崩溃恢复能力的事务安全（ACID兼容）能力，并要求实现并发控制，InnoDB 是个很好的选择。
2. 如果数据表主要用来插入和查询记录，则 MyISAM 引擎能提供较高的处理效率。
3. 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以将数据保存在内存中的 Memory 引擎。MySQL 中使用该引擎作为临时表，存放查询的中间结果。
   

## ACID

事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为**ACID特性**。

原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。

一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

## 事务的传播行为

1. PROPAGATION_REQUIRED                  propagation_required
   - 如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务。
2. PROPAGATION_REQUIRED_NEW       propagation_required_new
   - 当前的方法必须启动新事务，并在它自己的事务内运行，不管是否存着事务，都开启新事务。
3. PROPAGATION_SUPPORTS                 propagation_supports
   - 如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务的方式执行。
4. PROPAGATION_NOT_SUPPORTED    propagation_not_supported
   - 当前的方法不应该运行在事务中，如果有运行的事务，将它挂起
5. PROPAGATION_MANDATORY            propagation_mandatory
   - 如果当前存在事务，就加入当前事务，如果当前不存在事务，就抛出异常
6. PROPAGATION_NEVER                        propagation_never
   - 当前的方法不应该运行在事务中，如果当前存在事务，就抛出异常
7. PROPAGATION_NESTED                     propagation_nested
   - 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行。

## 索引最左匹配原则

- 最左匹配原则遇到范围查询就停止匹配，如>,<,between，范围查询后的无效，范围查询这一条有效。
- 建立索引时区分度高的在左，如性别区分度低，应该在右。

## 聚集索引和非聚集索引？

## B+树



# Spring

## spring依赖注入的方式

1. setter()注入
2. 构造器注入
3. @Autowired注解注入（反射）



## AOP

​        面向切面编程，由于存在很多组件和业务无关，如日志、事务等核心服务组件，如果为每一个具体业务都添加这些代码，代码冗余量太大，而且不便于维护，AOP通过动态代理的模式将需要注入切面的对象进行代理，不改变原有业务逻辑的同时对其进行增强。



## Spring Bean的生命周期总体分为四个阶段:

1. 实例化 CreateBeanInstance
2. 属性赋值 PopulateBeano
3. 初始化 Initialization
4. @销毁 Destruction**

反射创建bean工厂，属性注入，初始化，实例bean容器管理的对象，销毁

## spring支持的bean作用域有哪些?

- ### singleton

  使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例

- ### prototype

  使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例

- ### request

  该属性仅对HTTA请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。

- ### session

  该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。

- ### global-session

  该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。



## BeanFactory和FactoryBean的区别



# SpringMVC

## springMVC的处理过程

![image-20220212202647974](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220212202647974.png)

## springMVC的九大内置组件(三大核心组件)

1.HandlerMapping
根据request找到相应的处理器。因为Handler (Controller)有两种形式，一种是基于类的Handler，另一种是基于Method的Handler (也就是我们常用的)
2.HandlerAdapter
调用Handler的适配器。如果把Handler (Controller)当做工具的话，那么HandlerAdapter就相当于干活的工人
3.HandlerExceptionResolver
对异常的处理

4.ViewResolver
用来将String类型的视图名和Locale解析为View类型的视图5.RequestToViewNameTranslator
有的Handler (Controller)处理完后没有设置返回类型，比如是void方法，这是就需要从request中获取viewName
6.LocaleResolver
从request中解析出Locale。Locale表示一个区域，比如zh-cn，对不同的区域的用户，显示不同的结果
这就是i18n (SpringMVC中有具体的拦截器LocaleChangelnterceptor)

7.ThemeResolver
主题解析，这种类似于我们手机更换主题，不同的Ul，css等

8.MultipartResolver
处理上传请求，将普通的request封装成MultipartHttpServletRequest

9.FlashMapManager
用于管理FlashMap，FlashMap用于在redirect重定向中传递参数



## 三大组件

- **处理器映射器HandlerMapping**：用来帮助我们找到相应的Controller（类，处理器）；
- **处理器适配器HandlerAdapter**：用来帮助我们找到Controller里面相应的方法；返回结果ModelAndView，这里的view是一个jsp，jsp是不能直接放到浏览器进行渲染的，所以需要视图解析器。
- **视图解析器ViewResolver**：获取结果ModelAndView，解析成view对象。



# IO流

## java中IO流分为几种?

- 按照流的流向分，可以分为输入流和输出流;
- 按照操作单元划分，可以划分为字节流和字符流;
- 按照流的角色划分为节点流和处理流。

- Java lo流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系如下4个抽象类基类中派生出来的。
  - InputStream/Reader:所有的输入流的基类，前者是字节输入流，后者是字符输入流。
  - OutputStream/Writer:所有输出流的基类，前者是字节输出流，后者是字符输出流。



## BIO,NIO,AIO有什么区别?

- BIO: Block lO同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO:Non lO同步非阻塞IO，是传统lO的升级，客户端和服务器端通过Channel(通道)通讯，实现了多路复用。
- AlO: Asynchronous O是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。



## Files的常用方法都有哪些?

-  Files.exists():检测文件路径是否存在。
- Files. createFile():创建文件。
- Files.createDirectory():创建文件夹。
- Files. delete():删除一个文件或目录。
- Files.copy():复制文件。
- Files. move():移动文件。
- Files. size():查看文件个数。
- Files.read():读取文件。
- Files. write(): 写入文件。





# 多线程

## 创建多线程的方法

1. 继承Thread/实现Runable接口 复写run()方法
2. 实现Callable接口 复写call()方法，这个方法可以有返回值，可以声明抛出异常

## 线程的生命周期

- 新建状态:
  使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程。
- 就绪状态:
  当线程对象调用了start()方法之后，该线程就进入就绪状态。就缮状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- 运行状态:
  如果就绪状态的线程获取CPU资源，就可以执行run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
- 阻塞状态:
  如果一个线程执行了sleep(睡眠)、suspend(挂起)等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种:
  - 等待阻塞:运行状态中的线程执行wait()方法，使线程进入到等待阻塞状态。
  - 同步阻塞:线程在获取synchronized同步锁失败(因为同步锁被其他线程占用)。
  - 其他阻塞:通过调用线程的 sleep()或join()发出了VO请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。
- 死亡状态:
  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

## 线程和进程的区别

- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 一个进程中可以包含多个线程
- 多进程之间的内存区域相互独立，同一进程中的线程共享内存空间
- 一个进程崩溃不会影响别的进程，一个线程崩溃会导致所属的进程崩溃，所以多进程的健壮性更强
- 进程间的切换需要比较大的开销，同一进程内的线程的切换开销比较小

## 在Java程序中怎么保证多线程的运行安全

- 方法一:使用安全类，比如java.util.concurrent下的类，使用原子类AtomicInteger
- 方法二:使用自动锁synchronized。
- 方法三:使用手动锁Lock。

## 出现线程安全问题的原因

- 线程切换带来的原子性问题
- 缓存导致的可见性问题
- 编译优化带来的有序性问题



## 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法?

- new一个Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。
- 而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
- 总结:调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。

## Java 中用到的线程调度算法是什么

有两种调度模型：分时调度模型和抢占式调度模型。

- 分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
- Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。



## 什么是线程同步和线程互斥，有哪几种实现方式？

当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。

线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。

实现线程同步的方法

- 同步代码方法：sychronized 关键字修饰的方法
- 同步代码块：sychronized 关键字修饰的代码块
- 使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制
- 使用重入锁实现线程同步：reentrantlock类是可重入、互斥、实现了lock接口的锁，与sychronized方法具有相同的基本行为和语义



# 并发编程

## 并发编程三要素（线程的安全性问题体现在)

- 原子性:原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
- 可见性:一个线程对共享变量的修改,另一个线程能够立刻看到。(synchronized,volatile)
- 有序性:程序执行的顺序按照代码的先后顺序执行。(处理器可能会对指令进行重排序)

## 锁的三种形式

- 对于**普通同步方法**，锁是当前实例对象。
- 对于**静态同步方法**，锁是当前类的`Class`对象。
- 对于**同步代码块**，锁是`synchronized`括号里配置的对象。



## 防止死锁可以采用以下的方法

- 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
- 尽量使用 Java. util. concurrent 并发类代替自己手写锁。
- 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
- 尽量减少同步的代码块。
  

## 用户态和内核态

线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。


## AQS原理概览

- AQs核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

## CAS

- CAS是compare and swap的缩写，即我们所说的比较交换。
- cas是一种基于锁的操作，而且是乐观锁。在java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。
- CAS操作包含三个操作数——内存位置(V)、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么 a线程需要自旋，到下次循环才有可能机会执行。

### CAS的会产生什么问题?

1. ABA问题:
   比如说一个线程one 从内存位置V中取出A，这时候另一个线程two 也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功,但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference 来解决ABA问题。
2. 循环时间长开销大:
   对于资源竞争严重（线程冲突严重)的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
3. 只能保证一个共享变量的原子操作:
   当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。



## SynchronizedMap和ConcurrentHashMap有什么区别?

- SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map.ConcurrentHashMap使用分段锁来保证在多线程下的性能。
- ConcurrentHashMap中用了分段锁，一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get，put，remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。
- 另外ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new新的数据从而不影响原有的数据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。



## 形成死锁的四个必要条件是什么

1. 互斥条件:线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放
2. 请求与保持条件:一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程(进程)已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:当发生死锁时，所等待的线程(进程)必定会形成一个环路(类似于死循环)，造成永久阻塞



## happens-before

- as-if- serial语义的意思是:不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
- happens-before: A happens-before B就是A先行发生于B(这种说法不是很准确)，定义为hb(A,B)。在Java内存模型中，happens-before的意思是前一个操作的结果可以被后续操作获取。



### 为什么需要happens-before

- JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。

### 有哪些happens-before规则

- 程序次序规则:在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。
- 管程锁定规则:就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。(管程是一种通用的同步原语，synchronized就是管程的实现)
- volatile变量规则:就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。
- 线程启动规则:在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。
- 线程终止规则:在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。
- 线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。
- 传递性规则:这个简单的，就是happens-before原则具有传递性，即hb(A,B), hb(B,C)，那么hb(A，C)。
- 对象终结规则:这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定happens-before它的finalize()方法。

## ThreadPoolExecutor的饱和策略

- ThreadPoolExecutor.AbortPolicy:抛出RejectedExecutionException来拒绝新任务的处理。
- ThreadPoolExecutor.CallerRunsPolicy:调用“调用者”的线程运行任务。这种策略会降低新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
- ThreadPoolExecutor. DiscardPolicy: 不处理新任务，直接丢弃掉。
- ThreadPoolExecutor.DiscardOldestPolicy:此策略将丢弃最早的未处理的任务请求。

# 网络编程

## OSI七层模型

应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）

## TCP/IP四层模型

应用层、传输层、网络层、数据链路层

## TPC和UDP的区别

|              | UDP                                        | TCP                                    |
| ------------ | ------------------------------------------ | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一、一对多、多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的引用，例如文件传输 |

## 三次握手 四次挥手

### 为什么TCP连接的时候是3次?2次不可以吗?

- 因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。
- 如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。



### 为什么TCP连接的时候是3次，关闭的时候却是4次?

- 因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接?

- 这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办?

- TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



## Servlet是线程安全的吗

- Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。



## 	Servlet的生命周期

- Servlet 初始化后调用 **init ()** 方法。
- Servlet 调用 **service()** 方法来处理客户端的请求。
- Servlet 销毁前调用 **destroy()** 方法。



## 什么是HTTP，HTTP 与HTTPS的区别

- HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

| 区别     | HTTP                                                         | HTTPS                                                     |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 协议     | 运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份 | 运行于SSL上，SSL运行于TCP上，是添加了加密和认证机制的HTTP |
| 端口     | 80                                                           | 443                                                       |
| 资源消耗 | 较少                                                         | 由于加解密处理，会消耗更多的CPU和内存资源                 |
| 开销     | 无需证书                                                     | 需要证书，而证书一般需要向认证机构购买                    |
| 加密机制 | 无                                                           | 共享密钥加密和公开密钥加密并用的混合加密机制              |
| 安全性   | 弱                                                           | 由于加密机制，安全性强                                    |

## Session、Cookie、Token的区别

### session和cookie的区别

- cookie是服务器为了保存用户信息而在客户端浏览器保存的小文件。当浏览器请求服务器时会将cookie传给服务器来获取信息。
- session是为了保存用户信息而在服务器端分配的一块空间，客户端请求服务器时会读取保存在cookie中的sessionid来获取相应的数据。
- 综上cookie保存在客户端，session保存在服务端，session的安全性更高，但是会占用服务器性能。另外cookie的大小和数量在客户端会有限制，但是session在服务端没有限制。

### session和token的区别

- token是客户端第一次登录成功后，服务端生成一串字符串传递给客户端，以后客户端每次访问服务端，带上这个token即可请求数据。
- token传输时保存在
- 综上session保存在服务端，token保存在客户端，使用token对服务器的压力比较小；并且由于session保存在服务端，如果搭建了多个服务器，服务器之间的session不共享，就会导致获取不到session，但是token并不保存在服务端，服务端如果能成功解密客户端传来的token，并且读取到用户数据就能完成交互。

